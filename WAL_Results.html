<!DOCTYPE html>
<html>
	<head>
		<!-- <title>Web Archiving Livestream Performance Results Summary</title> -->
        <title>Results Mode</title>
		<script src="https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js"></script>
		
		<style>
			.centered{text-align: center; margin: auto}
            
            table, td{ border: 1px solid}
            th{border: 1px solid; background-color: lightgray; color: black}
            
            .button {
					border: none;
					color: black;
					text-align: center;
					text-decoration: none;
					display: inline-block;
					font-size: 14px;
					padding: 10px 16px;
					margin: 4px 2px;
					cursor: pointer;
				}
			.darkButton{color: white; background-color: #191919}
			.darkButton:hover{color: black; background-color: #bebebe;}
			.lightButton{color: black; background-color: #bebebe;}
			.lightButton:hover{color: white; background-color: #191919}
            
            .darkHeading{color: white; background-color: black; display: inline-block}
            .lightHeading{color: black; background-color: darkgray; display: inline-block}
            
            .positiveResultDiv, .negativeResultDiv{
                        border: solid;
                        border-width: 4px;
                        border-color: black red black red;
                        margin-left: auto;
                        margin-right: auto;
                        position: relative;
                        display: inline-block;
            }
            .negativeResultDiv{border-color: black green black green;}
            
            .positiveResultCenterLine, .negativeResultCenterLine{
                        border: solid;
                        border-width: 2px;
                        border-color: green;
                        width: 0px;
                        position: absolute;
                        display: inline-block;
            }
            .negativeResultCenterLine{border-color: red}
            
            .resultHeading, .resultAxis, .preferredBarSize{display:inline;}
            .resultHeading{font-size: 2rem;}
            .resultAxis{font-size: 1.75rem;}
            .preferredBarSize{font-size: 1.8rem; color: green}
            .resultDescription{display: inline-block; font-size: 1.5rem; margin:auto; text-align:left; padding-right: 10px;}
            .resultValue{display: inline-block; font-size: 1.5rem; margin:auto; text-align:right}
            .crawlerResultDiv{display: inline;}
            
            .score{display: inline-block; margin-top:0px; margin-bottom:0px}
            
            .bar{display:inline-block;}
		</style>
	</head>
	<body>
		<!-- QR Tutorial Used: https://medium.com/geekculture/few-ways-to-generate-qr-code-using-javascript-54b6b5220c4f -->
		<div id="qrcode"></div>
		
		<script type="text/javascript">
            const delay = ms => new Promise(res => setTimeout(res, ms));
            
            function getKnownCrawlerColor(crawlerName, crawlersList=null)
            {
                var name = crawlerName.toLowerCase();
                var knownCrawlersList = ["brozzler", "browsertrix", "wget", "wayback machine", "archive.today", "arquivo.pt"];
                var colorList = ["lightred", "cyan", "orange", "green", "purple", "pink", "yellow"];
                if(name == "brozzler")
                {
                    return "#6d9eebff";
                }
                else if(name == "browsertrix")
                {
                    return "#595959ff";
                }
                else
                {
                    var currentColor = "blue";
                    if(otherCrawlersList != null)
                    {
                        var unknownCounter = 0;
                        var currentCrawlerIndex = -1;
                        for(let index = 0; index < crawlersList.length; index++)
                        {
                            if(name == currentName)
                                currentCrawlerIndex = index;
                        }
                        
                        return colorList[currentCrawlerIndex];
                    }
                }
                
            }
            
            
            function range(stop, startAt=0) {
                rangeArray = [];
                for(let i = startAt; i < stop; i++)
                {
                    rangeArray.push(i);
                }
                return rangeArray;
            }
            
            function createQRCode(w=256, h=192, mainColor="#000000", backgroundColor="#FFFFFF")
			{
				var fileName = "WAL_Results.html";
				var queryString = window.location.search;
				var currentPage = (new URL("./"+ fileName, document.baseURI).href) + queryString;
				var customQRCodeConfiguration = {
													text: currentPage,
													width: w,
													height: h,
													colorDark: mainColor,
													colorLight: backgroundColor,

													correctLevel : QRCode.CorrectLevel.H
								};
												

                var qrDiv = document.getElementById("qrcode");
				var qrcode = new QRCode(qrDiv, customQRCodeConfiguration);
				
				//Center the QR code
				qrDiv.style.textAlign = "center";
				qrDiv.style.margin = "auto";
				var qrCodeImage = qrDiv.getElementsByTagName("img")[0];
				qrCodeImage.style.marginLeft = "auto";
				qrCodeImage.style.marginRight = "auto";
				
				//Move the tooltip from the qr div to qr image
				qrCodeImage.title = qrDiv.title;
				qrDiv.removeAttribute("title");
			}
			
			function getResultsObj()
			{
				queryString = window.location.search;
				const searchParams = new URLSearchParams(queryString);
				if(searchParams.has("d"))
				{
				    resultsObj = JSON.parse(atob(searchParams.get("d")));
				}
				else
				{
				    resultsObj = null;
				}
				return resultsObj;
			}
			
            function getScoringMetrics()
            {
                queryString = window.location.search;
                const searchParams = new URLSearchParams(queryString);
                if(searchParams.has("s"))
                {
                    scoringMetrics = searchParams.get("s").replaceAll(" ", "").split(",");
                    tempArray = []
                    for(let i = 0; i < scoringMetrics.length; i++)
                    {
                        if(!scoringMetrics[i].includes("-"))
                        {//Add each scoring metric to the new array
                            tempArray.push(parseInt(scoringMetrics[i]));
                        }
                        else
                        {//Add the range of scoring metrics to the new array
                            var begIndex = parseInt(scoringMetrics[i].split("-")[0]); console.log(begIndex);
                            var endIndex = parseInt(scoringMetrics[i].split("-")[1]); console.log(endIndex);
                            rangeArray = range(endIndex+1, startAt=begIndex); console.log(rangeArray);
                            tempArray = tempArray.concat(rangeArray); console.log(tempArray);
                        }
                    }
                    scoringMetrics = tempArray;
                }
                else
                {
                    scoringMetrics = null;
                }
                return scoringMetrics;
            }
            
			function getColHeadings(resultsObj)
            {
                colHeaders = [];
                if(resultsObj["v"] == "1.0")
                {
                    ///Example row: ["brozzler",10,"0:07:10.221827",3,2,0,0,0,0,0,0,0,0,0,0,0,0,4,1]
                    //More cols may be added if there are other MIME types detected. Need to make the column headings fixed for all MIME types for the next version.
                    colHeaders = ["Crawler Name", "Number of URLs Archived", "Completion Times", "Number of 404s", "Number of Other Client or Server Error Responses", "Number of Missing CSS Files", "Number of Missing JavaScript Files", "Number of Missing Image Files", "Number of Missing Video Files", "Number of Missing Audio Files", "Number of Missing text/html Files", "Number of Missing warc/revisit Files"];
                }
                
                return colHeaders;
            }
            
			//Tutorial Used: https://www.geeksforgeeks.org/how-to-create-and-download-csv-file-in-javascript/
			function createResultsFile(resultsObj, downloadBtn)
			{
				const convertToCSV = function (resultsObj) 
				{
				    csvRows = [];
				    
				    colHeaders = getColHeadings(resultsObj);

				    //Add column headers to CSV
				    csvRows.push(colHeaders.join(','));
				 
				    // Add the other rows to the csv array
				    for(let index = 0; index < resultsObj["data"].length; index++)
				    {
				    	const row = resultsObj["data"][index];
				    	csvRows.push(row.join(','));
				    }
				 
				    // Returning a string that can be used for the csv file
				    return csvRows.join('\n')
				}
							
				const downloadCSV = function (csvStr, resultsObj) {
				 
				    // Creating a Blob that has a csv file format
				    const blob = new Blob([csvStr], { type: 'text/csv' });
				 
				    // Creating an object for downloading url
				    const url = window.URL.createObjectURL(blob)
				 
				    // Creating an anchor(a) tag that is used for downloading the file
				    const a = document.createElement('a')
				    
				    a.setAttribute('href', url)
				 
				    // Setting the anchor tag attribute for downloading
				    // and passing the download file name
				    a.setAttribute('download', resultsObj["date"] + '_Web_Archiving_Livestream_Results.csv');
				 
				    // Performing a download with click
				    a.click()
				}
				
				const getCSV = /*async*/ function (resultsObj) 	{	 
										    const csvStr = convertToCSV(resultsObj);
										    downloadCSV(csvStr, resultsObj);
										}
										
				downloadBtn.onclick = function(){getCSV(resultsObj)};
			}			
			
			
			function createButtons(resultsObj, scoringMetrics, scoreMultiplierList, viewedScoresList)
			{
				var qrDiv = document.getElementById("qrcode");
				var buttonRow1 = document.createElement("div");
				buttonRow1.style.textAlign = "center";
				buttonRow1.style.margin = "auto";
				
				var downloadResultsButton = document.createElement("button");
				downloadResultsButton.type = "button";
				downloadResultsButton.className = "button darkButton";
				downloadResultsButton.innerHTML = "Download Results";
                downloadResultsButton.id = "download_results_btn";
				createResultsFile(resultsObj, downloadResultsButton);
				
				var viewRoundButton = document.createElement("button");
				viewRoundButton.type = "button";			
				viewRoundButton.className = "button darkButton";
				viewRoundButton.innerHTML = "Watch Round";
                viewRoundButton.id = "view_round_btn";
				if(resultsObj.hasOwnProperty("video"))
					viewRoundButton.onclick = function(){window.open(resultsObj["video"], "_blank")};
				
				buttonRow1.appendChild(downloadResultsButton);			
				buttonRow1.appendChild(viewRoundButton);
				qrDiv.appendChild(buttonRow1);
                
				var resultButtons = document.createElement("div");
                resultButtons.style.textAlign = "center";
                resultButtons.style.margin = "auto";
                qrDiv.appendChild(resultButtons);
                
                var prevResultButton = document.createElement("button");
                prevResultButton.type = "button";
                prevResultButton.className = "button darkButton";
                prevResultButton.innerHTML = "Previous Metric";
                prevResultButton.id = "prev_metric_btn";
                if(scoringMetrics != null && scoringMetrics.length > 1)
                {
                    prevResultButton.onclick = function(){
                        var resultContainer = document.getElementById("current_result");
                        var currentScoringMetricIndex = 0;
                        if(resultContainer != null)
                            currentScoringMetricIndex = parseInt(resultContainer.getAttribute("data-scoringMetricIndex"));
                        
                        var prevScoringMetricIndex = scoringMetrics.length-1; //This is set to the last metric so that it will loop to the last metric if the current metric is the first metric
                        if( (currentScoringMetricIndex-1) >= 0)
                            prevScoringMetricIndex = currentScoringMetricIndex - 1;
                        
                        console.log(prevScoringMetricIndex, scoringMetrics);
                        document.getElementById("current_result").remove();
                        displayResult(resultsObj, scoringMetrics, prevScoringMetricIndex, scoreMultiplierList, viewedScoresList);
                    };
                }
                
                
                var nextResultButton = document.createElement("button");
                nextResultButton.type = "button";
                nextResultButton.className = "button darkButton";
                nextResultButton.innerHTML = "Next Metric";
                nextResultButton.id = "next_metric_btn";
                if(scoringMetrics != null && scoringMetrics.length > 1)
                {
                    nextResultButton.onclick = function(){
                        var resultContainer = document.getElementById("current_result");
                        var currentScoringMetricIndex = 0;
                        if(resultContainer != null)
                            currentScoringMetricIndex = parseInt(resultContainer.getAttribute("data-scoringMetricIndex"));
                        
                        var nextScoringMetricIndex = 0; //This is set to 0 so that it will loop to the first metric if the current metric is the last metric
                        if( (currentScoringMetricIndex+1) < scoringMetrics.length)
                            nextScoringMetricIndex = currentScoringMetricIndex + 1;
                        
                        console.log(nextScoringMetricIndex, scoringMetrics);
                        document.getElementById("current_result").remove();
                        displayResult(resultsObj, scoringMetrics, nextScoringMetricIndex, scoreMultiplierList, viewedScoresList);
                    };
                }
                
                resultButtons.appendChild(prevResultButton);
                resultButtons.appendChild(nextResultButton);
			}
            
            function displayTitleandCrawlerNames(resultsObj)
            {
                var commonClassName = "darkHeading";
                var outerPadding = 40;
                var totalSpaceUsed = 0;
                var qrCodeDiv = document.body.children[0];
                var numCrawlers = resultsObj["data"].length;
                
                var parentDiv = document.createElement("div");
                parentDiv.style.width = (document.body.clientWidth).toString() + "px";
                parentDiv.className = "centered " + commonClassName;
                //document.body.insertBefore(document.createElement("br"), document.body.children[0]);
                document.body.insertBefore(document.createElement("br"), document.body.children[0]);
                document.body.insertBefore(parentDiv, document.body.children[0]);
                
                //Add title
                var title = document.createElement("h1");
                title.innerHTML = "Web Archiving Livestream Performance Results Summary";
                title.className = commonClassName;
                parentDiv.appendChild(title);
                totalSpaceUsed += title.getBoundingClientRect()["width"];
                
                //Add crawlers' names
                var crawlerNameArray = [];
                for(let index = 0; index < resultsObj["data"].length; index++)
                {
                    crawlerNameArray.push(document.createElement("h1"));
                    crawlerNameArray[index].innerHTML = resultsObj["data"][index][0];
                    crawlerNameArray[index].className = commonClassName;
                    
                    if(index < Math.round(resultsObj["data"].length / 2))
                    {
                        parentDiv.insertBefore(crawlerNameArray[index], title);
                    }
                    else if(index >= Math.round(resultsObj["data"].length / 2))
                    {
                        parentDiv.appendChild(crawlerNameArray[index]);
                    }
                    totalSpaceUsed += crawlerNameArray[index].getBoundingClientRect()["width"];
                }
                
                //Update the spacing between headings
                for(let index = 0; index < crawlerNameArray.length; index++)
                {
                    var padding = Math.floor((document.body.clientWidth - totalSpaceUsed - outerPadding) / (crawlerNameArray.length + 1 - 1));
                    if(index < Math.round(crawlerNameArray.length / 2))
                    {
                        crawlerNameArray[index].style.paddingRight = padding.toString() + "px";
                    }
                    else if(index >= Math.round(crawlerNameArray.length / 2))
                    {
                        crawlerNameArray[index].style.paddingLeft = padding.toString() + "px";
                    }
                }
                
                //Add the lines for the scores
                /* Example code
                 <div class="centered darkHeading" style="width: 1904px;">
                    <h1 class="darkHeading" style="padding-right: 389px;">Brozzler</h1>
                    <h1 class="darkHeading">Web Archiving Livestream Performance Results Summary</h1>
                    <h1 class="darkHeading" style="padding-left: 389px;">Browsertrix</h1>
                 </div>
                 <br> //Only one br instead of two
                    // Need to have the score text as inline-block, no margins at top and bottom and need to compute the left margin based on the width that is taken up by the elements on the same line (use their widths and possibly left margin values)
                    <h1 style="display:inline-block; margin-top:0px; margin-bottom:0px; margin-left:20px">Score:</h1>
                    // The margin left for the point values are dependent on which score is higher the total or the current points
                        ///If it is the total points then take the left margin and width of "Score:" text and add it to the width of (total score width - new points width)
                    <h1 style="display:inline-block; margin-top:0px; margin-bottom:0px; margin-left:80px">0</h1>
                    <h1 style="display:inline-block; margin-top:0px; margin-bottom:0px; margin-left:1500px">Score:</h1>
                    <h1 style="display:inline-block; margin-top:0px; margin-bottom:0px; margin-left:80px">0</h1>
                    <br>
                    <h1 style="display:inline-block; margin-top:0px; margin-bottom:0px; margin-left:105px; color:green">
                        + 2,570
                    </h1>
                    <h1 style="display:inline-block; margin-top:0px; margin-bottom:0px; margin-left:1585px; color:green">
                        + 2,723
                    </h1>
                    <div id="qrcode" style="text-align: center; margin: auto;"><canvas width="256" height="192" style="display: none;"></canvas><img title="https://treid003.github.io/WAL_Results.html?d=eyJ2IjoiMS4wIiwiZGF0ZSI6IjIwMjItMDctMjciLCJ2aWRlbyI6Imh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9TTVqTDd1SFFDZncmdD0yMnMiLCJkYXRhIjpbWyJCcm96emxlciIsMTAsIjA6MDc6MTAuMjIxODI3IiwzLDIsMCwwLDAsMCwwLDQsMV0sWyJCcm93c2VydHJpeCIsMTAsIjA6MDQ6MzcuMDMxNTIwIiwyLDAsMCwwLDAsMCwwLDAsMF1dfQ==&amp;s=2,5-10"
                 */
                var qrCodeDivChildIndex = 2;
                var scoreClass = "score";
                var spaceBetweenTextAndValue = 10;
                var scoreDiv = document.createElement("div");
                //Add an attribute to that will be used to determine when the scores are finished updating
                scoreDiv.setAttribute("data-updating", 1);
                document.body.insertBefore(scoreDiv, qrCodeDiv);
                qrCodeDivChildIndex += 1;
                scoreDiv.style.width = parentDiv.style.width;
                scoreDiv.id = "total_scores";
                var newPointsDiv = scoreDiv.cloneNode(true);
                newPointsDiv.id = "metric_points";
                document.body.insertBefore(newPointsDiv, qrCodeDiv);
                qrCodeDivChildIndex += 1;
                

                
                totalSpaceUsed = 0;
                
                var scoreOneText = document.createElement("h1");
                scoreDiv.appendChild(scoreOneText);
                scoreOneText.className = scoreClass;
                scoreOneText.innerHTML = "Score:";
                totalSpaceUsed += scoreOneText.getBoundingClientRect()["width"] * numCrawlers;
                scoreOneText.style.paddingLeft = Math.floor(outerPadding / 2).toString() + "px";
                var scoreOneValue = scoreOneText.cloneNode(true);
                scoreDiv.appendChild(scoreOneValue);
                scoreOneValue.innerHTML = "0";
                totalSpaceUsed += scoreOneValue.getBoundingClientRect()["width"] * numCrawlers;
                scoreOneValue.style.paddingLeft = spaceBetweenTextAndValue.toString() + "px";
                var scoreOneMetricPoints = scoreOneValue.cloneNode(true);
                scoreOneMetricPoints.innerHTML = "";
                newPointsDiv.appendChild(scoreOneMetricPoints);
                
                var scoreTwoText = scoreOneText.cloneNode(true);
                scoreDiv.appendChild(scoreTwoText);
                scoreTwoText.style.paddingLeft = "0px";
                var scoreTwoValue = scoreOneValue.cloneNode(true);
                scoreDiv.appendChild(scoreTwoValue);
                var scoreTwoMetricPoints = scoreOneMetricPoints.cloneNode(true);
                newPointsDiv.appendChild(scoreTwoMetricPoints);
                
                ///Adjust the spacing between the total scores
                var padding = Math.floor((parseInt(scoreDiv.style.width) - totalSpaceUsed - spaceBetweenTextAndValue*numCrawlers) / (numCrawlers - 1));
                scoreOneValue.style.paddingRight = padding.toString() + "px";
                
                //Finished updating initial scores
                scoreDiv.setAttribute("data-updating", 0);
            }
            
            function createTable(resultsObj)
            {
                var table = document.createElement("table");
                document.body.appendChild(document.createElement("br"));
                document.body.appendChild(document.createElement("br"));
                document.body.appendChild(table);
                
                //Add the column headings
                var columnHeadings = document.createElement("thead");
                table.appendChild(columnHeadings);
                columnHeadings.appendChild(document.createElement("tr"));
                var colHeaders = getColHeadings(resultsObj);
                for(const colHeading of colHeaders)
                {
                    headingElement = document.createElement("th");
                    headingElement.innerHTML = colHeading;
                    columnHeadings.children[0].appendChild(headingElement);
                    
                }
                
                //Add data for the rows
                for(let index = 0; index < resultsObj["data"].length; index++)
                {
                    const row = resultsObj["data"][index];
                    var currentRow = document.createElement("tr");
                    table.appendChild(currentRow);
                    for(const cell of row)
                    {
                        var currentCellElement = document.createElement("td");
                        currentRow.appendChild(currentCellElement);
                        currentCellElement.innerHTML = cell;
                        
                        ///Right align numbers
                        if(!isNaN(parseInt(cell)))
                        {
                            currentCellElement.style.textAlign = "right";
                        }
                        
                    }
                    
                }
            }
			
            function getMetricUpperLimit(maxValue)
            {
                var maxValueStr = 0;
                var metricLimit = 0;
                if(Math.floor(maxValue) >= 0)
                {
                    maxValueStr = maxValue.toString().replace(",", "").split(".")[0];
                    metricLimit = maxValue + Math.pow(10, maxValueStr.length - 1);
                }
                else
                {
                    maxValueStr = maxValue.toString().replace(",", "").split(".")[1];
                    metricLimit = maxValue + Math.pow(10, -(maxValueStr.length - 1));
                }
                
                return metricLimit;
            }
            
            function getScoreObj(resultsObj, defaultMetricValues, performanceMetricIndex, scoreMultiplier, maxMetricVal=-1)
            {
                var scoreObj = {};
                var colHeaders = getColHeadings(resultsObj);
                var headingLowerCase = colHeaders[performanceMetricIndex].toLowerCase();
                
                //Get metric name
                var metricName = "Invalid Metric";
                if(headingLowerCase.includes("completion time"))
                {
                    metricName = "Speedrun Time";
                }
                else if(headingLowerCase.includes("number of 404s"))
                {
                    metricName = "Number of 404s";
                }
                else if(headingLowerCase.includes("client or server error responses"))
                {
                    metricName = "Number of 4XX or 5XX HTTP Status Codes";
                }
                else if(headingLowerCase.includes("files"))
                {
                    metricName = colHeaders[performanceMetricIndex].replace("Number of ", "");
                }
                else
                {
                    metricName = colHeaders[performanceMetricIndex];
                }
                scoreObj["metric_name"] = metricName;
                
                
                scoreObj["crawler_list"] = [];
                scoreObj["metric_upper_limit"] = 0;
                
                
                
                if(colHeaders[performanceMetricIndex].includes("Completion Time"))
                {
                    scoreObj["prefer_high_metric_value"] = false;
                    var numPages = resultsObj["data"][0][1];
                    scoreObj["fixed_max_metric_value"] = defaultMetricValues["max_time_per_page"] * numPages;
                    for(let crawlerIndex = 0; crawlerIndex < resultsObj["data"].length; crawlerIndex++)
                    {
                        var currentCrawler = {};
                        var crawlerName = resultsObj["data"][crawlerIndex][0];
                        currentCrawler["crawler_name"] = crawlerName;
                        
                        //Original metric without the fraction of a second
                        var speedrunTimeStr = resultsObj["data"][crawlerIndex][performanceMetricIndex].split(".")[0];
                        
                        //Alternative metric value for the time that was will be converted to seconds
                        ///Convert the datetime string to seconds for each crawler
                        var timeArray = speedrunTimeStr.split(":").reverse();
                        
                        ////Add the seconds (and exlude the fraction of a second)
                        currentCrawler["metric_value"] = Math.floor(timeArray[0]);
                        
                        ////Add minutes
                        if(timeArray.length > 1)
                            currentCrawler["metric_value"] += timeArray[1] * 60;
                            
                        ////Add hours
                        if(timeArray.length > 2)
                            currentCrawler["metric_value"] += timeArray[2] * 60 * 60;
                            
                        ////Add days
                        if(timeArray.length > 3)
                            currentCrawler["metric_value"] += timeArray[3] * 60 * 60 * 24;
                        
                        
                        ///Compute the score for the metric
                        if(maxMetricVal == -1)
                        {
                            var numPages = resultsObj["data"][0][1];
                            currentCrawler["metric_score"] = Math.abs(scoreObj["fixed_max_metric_value"] - currentCrawler["metric_value"]) * scoreMultiplier;
                        }
                        else
                        {
                            currentCrawler["metric_score"] = Math.abs(maxMetricVal - currentCrawler["metric_value"]) * scoreMultiplier;
                        }
                        
                        if(currentCrawler["metric_value"] > scoreObj["metric_upper_limit"])
                        {
                            scoreObj["metric_upper_limit"] = currentCrawler["metric_value"];
                        }
                        
                        //Add the unit of time to the metric value
                        currentCrawler["metric_value"] = currentCrawler["metric_value"].toString() + "s";
                        
                        //Add the crawler's score object to scoreObj
                        scoreObj["crawler_list"].push(currentCrawler);
                    }
                    
                    //Get the upper limit for the score
                    scoreObj["metric_upper_limit"] = getMetricUpperLimit(scoreObj["metric_upper_limit"]);
                    
                    //Add the unit of time to the metric value
                    scoreObj["metric_upper_limit"] = scoreObj["metric_upper_limit"].toString() + "s";
                }
                else if(headingLowerCase.includes("number of 404s") || headingLowerCase.includes("error responses") || headingLowerCase.includes("missing"))
                {
                    scoreObj["prefer_high_metric_value"] = false;
                    for(let crawlerIndex = 0; crawlerIndex < resultsObj["data"].length; crawlerIndex++)
                    {
                        var currentCrawler = {};
                        var crawlerName = resultsObj["data"][crawlerIndex][0];
                        currentCrawler["crawler_name"] = crawlerName;
                        currentCrawler["metric_value"] = resultsObj["data"][crawlerIndex][performanceMetricIndex];
                        
                        ///Compute the score for the metric
                        currentCrawler["metric_score"] = currentCrawler["metric_value"] * scoreMultiplier * -1;
                        
                        if(currentCrawler["metric_value"] > scoreObj["metric_upper_limit"])
                        {
                            scoreObj["metric_upper_limit"] = currentCrawler["metric_value"];
                        }
                        
                        //Add the crawler's score object to scoreObj
                        scoreObj["crawler_list"].push(currentCrawler);
                    }
                    
                    //Get the upper limit for the score
                    scoreObj["metric_upper_limit"] = getMetricUpperLimit(scoreObj["metric_upper_limit"]);
                }
                
                
                return scoreObj;
            }
            
            //May remove this function if I want it all to be included in displayResult
            function createVisualization(scoreObj)
            {
                
            }
            
            const updateScore = async(resultsObj, scoreObj, spaceBetweenTextAndValue=10, scoreAnimationDelay=1.5) => {
                /**
                    When adjusting the padding:
                        1. Check if the total score is larger than the points for the metric
                            1.1 If the total score is larger, then the padding on the right (if score after median) and the previous element's right padding (if score before median) does not need to be updated for the total score line
                            1.2 If the total score is smaller, then the padding on the right or the previous element's right padding will need to be changed
                        2. Before adjusting the padding need to store the previous right and left padding for the current total score and store the right padding for the previous total score element
                        3. Compute the difference between the string widths for the scores
                        4. Use the string widths to determine how many pixels that one of the scores need to be shifted
                            4.1 Update the left padding for the smallest score
                            4.2 Two possible updates needed for adjusting padding
                                4.2.1 If the total is larger, then stop at 4.1, the right padding for the smaller score will stay the same
                                4.2.2 If the total is smaller, then two possible changes:
                                    4.2.2.1 If the total is on the left side of the median, then reduce the right padding for the total and the metric points (this results in left alignment of the test)
                                    4.2.2.2 If the total is on the right side of the median, then reduce the right padding for the previous total and metric points so that the numbers for the current points are right aligned
                 */
                //Wait until the scores are finished being updated by a different function call
                scoreDiv = document.getElementById("total_scores");
                while(parseInt(scoreDiv.getAttribute("data-updating")) == 1)
                {
                    await delay(1000);
                }
                
                //Start to update the scores
                scoreDiv = document.getElementById("total_scores");
                scoreDiv.setAttribute("data-updating", 1);
                
                var numCrawlers = resultsObj["data"].length;
                var medianIndex = Math.ceil(numCrawlers / 2) - 1;
                for(let index = 0; index < numCrawlers; index++)
                {
                    //Update the score for the current crawler
                    var metricPointsElement = document.getElementById("metric_points").children[index];
                    var totalScoreIndex = (index + 1) * 2 - 1;
                    var totalScoreElement = document.getElementById("total_scores").children[totalScoreIndex];
                    var totalScoreTextElement = document.getElementById("total_scores").children[totalScoreIndex - 1];
                    
                    var metricPointsValue = scoreObj["crawler_list"][index]["metric_score"];
                    var totalScore = parseInt(totalScoreElement.innerHTML);
                    
                    
                    operatorStr = "";
                    if(metricPointsValue > 0)
                    {
                        operatorStr = "+";
                        metricPointsElement.style.color = "green";
                    }
                    else if(metricPointsValue < 0)
                    {
                        
                        operatorStr = "-";
                        metricPointsElement.style.color = "red";
                    }
                    else
                    {
                        metricPointsElement.style.color = "black";
                    }
                    metricPointsElement.innerHTML = operatorStr;

                    ///Setup before adjusting the padding
                    var prevTotalScoreElement = null;
                    var prevMetricScoreElement = null;
                    var spaceBetweenScores = "0px";
                    if(index > 0)
                    {
                        prevTotalScoreElement = document.getElementById("total_scores").children[totalScoreIndex - 2];
                        prevMetricScoreElement = document.getElementById("metric_points").children[index - 1];
                        spaceBetweenScores = prevTotalScoreElement.style.paddingRight;
                    }
                    
                    
                    //var prevTotalScoreWidth  = parseInt(getComputedStyle(totalScoreElement)["width"]);
                    //var pmetricPointsWidth = parseInt(getComputedStyle(metricPointsElement)["width"]);
                    
                    ///Store the padding values
                    var prevLeftPaddingNum = parseFloat(totalScoreElement.style.paddingLeft);
                    var prevRightPaddingNum = parseFloat(totalScoreElement.style.paddingRight);
                    
                    ///Reset the padding and get the width of the text for the current metric points and the current crawler score
                    ////For metric points
                    metricPointsElement.style.paddingLeft = "0px";
                    metricPointsElement.style.paddingRight = "0px";
                    metricPointsElement.innerHTML = metricPointsElement.innerHTML +  Math.abs(metricPointsValue).toString();
                    ////For total score
                    totalScoreElement.style.paddingLeft  = "0px";
                    totalScoreElement.style.paddingRight = "0px";
                    
                    ///Get the widths for the score elements
                    var totalScoreWidth  = totalScoreElement.getBoundingClientRect()["width"] - parseFloat(totalScoreElement.style.paddingLeft) -  parseFloat(totalScoreElement.style.paddingRight);
                    var metricPointsWidth = metricPointsElement.getBoundingClientRect()["width"] - parseFloat(metricPointsElement.style.paddingLeft) -  parseFloat(metricPointsElement.style.paddingRight);
                    ///Compute the difference in the string widths for the scores
                    var widthDiff = Math.abs(totalScoreWidth - metricPointsWidth);
                    
                    ///Update the padding for the total score and metric score
                    if(totalScoreWidth >= metricPointsWidth)//totalScore.toString().length >= (operatorStr + Math.abs(metricPointsValue).toString()).length)
                    {
                        ///Update total score element's padding
                        totalScoreElement.style.paddingLeft = prevLeftPaddingNum.toString() + "px";
                        totalScoreElement.style.paddingRight = prevRightPaddingNum.toString() + "px";
                        
                        ///Update metric score element's padding
                        metricPointsElement.style.paddingLeft = (totalScoreTextElement.getBoundingClientRect()["width"] + prevLeftPaddingNum + widthDiff).toString() + "px"; //- parseFloat(totalScoreElement.style.paddingRight) - metricPointsElement.getBoundingClientRect()["width"]).toString() + "px";
                        
                        metricPointsElement.style.paddingRight = prevRightPaddingNum.toString() + "px";
                    }
                    else
                    {
                        if(index <= medianIndex)
                        {///Left align the "Score:" text to the beginning of the crawler name
                            metricPointsElement.style.paddingRight = (prevRightPaddingNum - widthDiff).toString() + "px";
                        }
                        else
                        {///Right align the total score to the end of the crawler name
                            prevTotalScoreElement.style.paddingRight = (parseFloat(prevTotalScoreElement.style.paddingRight) - widthDiff).toString() + "px";
                            prevMetricScoreElement.style.paddingRight = (parseFloat(prevMetricScoreElement.style.paddingRight) - widthDiff).toString() + "px";
                            if((prevRightPaddingNum - widthDiff) > 0)
                                metricPointsElement.style.paddingRight = (prevRightPaddingNum - widthDiff).toString() + "px";
                            else
                                metricPointsElement.style.paddingRight = "0px";
                            
                        }
                        //These padding values will be the same for both cases
                        metricPointsElement.style.paddingLeft = (totalScoreTextElement.getBoundingClientRect()["width"] + spaceBetweenTextAndValue).toString() + "px";
                        totalScoreElement.style.paddingLeft = (spaceBetweenTextAndValue + widthDiff).toString() + "px";
                        totalScoreElement.style.paddingRight = metricPointsElement.style.paddingRight;
                        
                    }

                    ///Update score animation
                    await delay(scoreAnimationDelay * 1000);
                    var previousWidth = totalScoreElement.getBoundingClientRect()["width"] - parseFloat(totalScoreElement.style.paddingLeft) - parseFloat(totalScoreElement.style.paddingRight);//parseFloat(getComputedStyle(totalScoreElement)["width"]);//Width with padding
                    
                    //Update the padding around the total score
                    prevLeftPaddingNum = parseFloat(totalScoreElement.style.paddingLeft);
                    prevRightPaddingNum = parseFloat(totalScoreElement.style.paddingRight);
                    totalScoreElement.style.paddingLeft = spaceBetweenTextAndValue.toString() + "px";
                    if(index <= medianIndex)
                    {
                        totalScoreElement.style.paddingRight = (parseFloat(totalScoreElement.style.paddingRight) + (prevLeftPaddingNum - spaceBetweenTextAndValue)).toString() + "px";//If left padding is adjusted, then update right padding
                    }
                    else
                    {
                        prevTotalScoreElement.style.paddingRight = (parseFloat(prevTotalScoreElement.style.paddingRight) + (prevLeftPaddingNum - spaceBetweenTextAndValue)).toString() + "px";//If left padding is adjusted, then update right padding
                    }
                    
                    //Update total score value
                    metricPointsElement.style.color = "white";//Make it fade into the background so that the padding is not affected for the other score
                    totalScoreElement.innerHTML = (totalScore + metricPointsValue).toString();
                    
                    ///Update the padding based on the new score width
                    ////Compute the difference between the previous total score width and the current width
                    totalScoreWidth = totalScoreElement.getBoundingClientRect()["width"] - parseFloat(totalScoreElement.style.paddingLeft) - parseFloat(totalScoreElement.style.paddingRight);
                    widthDiff = Math.abs(totalScoreWidth - previousWidth);
                    console.log(totalScoreWidth, previousWidth);
                    console.log(widthDiff.toString());
                    if(index <= medianIndex && previousWidth < totalScoreWidth)
                    {
                        totalScoreElement.style.paddingRight = (parseFloat(totalScoreElement.style.paddingRight) - widthDiff).toString() + "px";
                    }
                    else if(index <= medianIndex && previousWidth > totalScoreWidth)
                    {
                        totalScoreElement.style.paddingRight = (parseFloat(totalScoreElement.style.paddingRight) + widthDiff).toString() + "px";
                    }
                    //*
                    else if(index > medianIndex && previousWidth < totalScoreWidth)
                    {
                        prevTotalScoreElement.style.paddingRight = (parseFloat(prevTotalScoreElement.style.paddingRight) - widthDiff).toString() + "px";
                    }
                    else if(index > medianIndex && previousWidth > totalScoreWidth)
                    {
                        prevTotalScoreElement.style.paddingRight = (parseFloat(prevTotalScoreElement.style.paddingRight) + widthDiff).toString() + "px";
                    }
                    //*/ /*
                    
                    //Copy the values over from the total score to the metric score so that it aligns properly (the text for the metric scores should be the same as the background)
                    metricPointsElement.innerHTML = totalScoreElement.innerHTML;
                    metricPointsElement.style.paddingRight = totalScoreElement.style.paddingRight;
                    metricPointsElement.style.paddingLeft = (totalScoreTextElement.getBoundingClientRect()["width"] + parseFloat(totalScoreElement.style.paddingLeft)).toString() + "px";
                    if(index > 0)
                    {
                        prevMetricScoreElement.style.color = "white";//Make it fade into the background so that the padding is not affected for the other score
                        prevMetricScoreElement.innerHTML = prevTotalScoreElement.innerHTML;
                        prevMetricScoreElement.style.paddingRight = prevTotalScoreElement.style.paddingRight;
                    }
                    //*/
                    
                }
                scoreDiv.setAttribute("data-updating", 0);
            }
            
            function displayResult(resultsObj, scoringMetrics, scoringMetricIndex, scoreMultiplierList, viewedScoresList, scoreAnimationDelay=1.5, width=0, height=0)
            {
                var defaultMetricValues = {"max_time_per_page": 5 * 60};
                var defaultHeight = 40;
                var defaultBorderWidth = 4;
                
                
                var performanceMetricIndex = scoringMetrics[scoringMetricIndex];
                var scoreObj = getScoreObj(resultsObj, defaultMetricValues, performanceMetricIndex, scoreMultiplierList[scoringMetricIndex]);

                var preferredBarSize = "";
                var barClass = "";
                var middleAxisValue = 0;
                if(scoreObj["prefer_high_metric_value"])
                {
                    preferredBarSize = "Larger Bar is Better";
                    barClass = "positiveResultDiv";
                    lineClass = "positiveResultCenterLine";
                }
                else
                {
                    preferredBarSize = "Smaller Bar is Better";
                    barClass = "negativeResultDiv";
                    lineClass = "negativeResultCenterLine";
                }
                middleAxisValue = scoreObj["metric_upper_limit"];
                
                var resultContainer = document.createElement("div");
                resultContainer.id = "current_result";
                resultContainer.setAttribute("data-scoringMetricIndex", scoringMetricIndex);
                document.body.appendChild(resultContainer);
                resultContainer.appendChild(document.createElement("br"));
                resultContainer.appendChild(document.createElement("br"));
                
                var resultLineDiv = document.createElement("div");
                resultLineDiv.className = "centered";
                resultLineDiv.style.position = "relative";
                resultLineDiv.style.width = (document.body.clientWidth).toString() + "px";
                resultContainer.appendChild(resultLineDiv);
                
                var barDiv = document.createElement("div");
                barDiv.className = barClass;
                
                if(width == 0)
                {
                    width = Math.floor(document.body.clientWidth * 0.5);
                }
                if(height == 0)
                {
                    height = defaultHeight;
                }
                barDiv.style.width = width.toString() + "px";
                barDiv.style.height = height.toString() + "px";
                
                resultLineDiv.appendChild(barDiv);
                
                var centerLine = document.createElement("div");
                centerLine.className = lineClass;
                centerLine.style.height = barDiv.style.height;
                centerLine.style.left = Math.floor( (document.body.clientWidth - defaultBorderWidth) / 2 ).toString() + "px"; //Center the line (the border width will make the line slightly off from the center)
                resultLineDiv.insertBefore(centerLine, barDiv);
                
                /// Display average or total for result for each crawler (when >2 crawlers can use vertical bar chart with d3)
                //
                var resultHeadingDiv = document.createElement("div");
                resultHeadingDiv.className = "centered";
                resultHeadingDiv.style.position = "relative";
                resultHeadingDiv.style.width = (document.body.clientWidth).toString() + "px";
                resultContainer.insertBefore(resultHeadingDiv,resultLineDiv);
                
                totalSpaceUsed = 0;
                //Add crawlers' names
                var resultHeadingClass = "resultHeading";
                var numCrawlers = resultsObj["data"].length;
                for(let index = 0; index < numCrawlers; index++)
                {
                    var currentCrawlerNameDiv = document.createElement("h1");
                    var crawlerName = resultsObj["data"][index][0];
                    currentCrawlerNameDiv.innerHTML = crawlerName;
                    currentCrawlerNameDiv.className = resultHeadingClass;
                    currentCrawlerNameDiv.style.color = getKnownCrawlerColor(crawlerName);
                    resultHeadingDiv.appendChild(currentCrawlerNameDiv);
                    
                    totalSpaceUsed += currentCrawlerNameDiv.getBoundingClientRect()["width"];
                }
                
                //Add metric name
                var metricTitle = document.createElement("h1");
                metricTitle.innerHTML = scoreObj["metric_name"];
                metricTitle.className = resultHeadingClass;
                var metricTitleIndex = Math.ceil(resultHeadingDiv.children.length / 2);
                resultHeadingDiv.insertBefore(metricTitle, resultHeadingDiv.children[metricTitleIndex]);
                totalSpaceUsed += metricTitle.getBoundingClientRect()["width"];
                
                ///Adjust the spacing between the result headings
                var spacingBetweenHeadings = Math.floor((width - totalSpaceUsed) / (numCrawlers + 1 - 1));
                for(let index = 0; index < numCrawlers; index++)
                {
                    resultHeadingDiv.children[index].style.paddingRight = spacingBetweenHeadings.toString() + "px";
                }
                
                //Add the axis numbers for the gaming visualization
                var resultAxisDiv = document.createElement("div");
                resultAxisDiv.className = "centered";
                resultAxisDiv.style.position = "relative";
                resultAxisDiv.style.width = (document.body.clientWidth).toString() + "px";
                resultContainer.appendChild(resultAxisDiv);
                
                totalSpaceUsed = 0;
                
                var resultAxisClass = "resultAxis";
                var numAxisValues = 3;
                for(let index = 0; index < numAxisValues; index++)
                {
                    var currentAxisValueDiv = document.createElement("h2");
                    
                    if(index != 1)
                        currentAxisValueDiv.innerHTML = 0;
                    else
                        currentAxisValueDiv.innerHTML = middleAxisValue;
                    
                    currentAxisValueDiv.className = resultAxisClass;
                    resultAxisDiv.appendChild(currentAxisValueDiv);
                    
                    totalSpaceUsed += currentAxisValueDiv.getBoundingClientRect()["width"];
                }
                
                ///Adjust the spacing between the axis values
                var spacingBetweenAxisValues = Math.floor((width - totalSpaceUsed) / (numAxisValues - 1));
                for(let index = 0; index < numCrawlers; index++)
                {
                    resultAxisDiv.children[index].style.paddingRight = spacingBetweenAxisValues.toString() + "px";
                }
                
                //Display the preferred bar size
                var preferredBarSizeDiv = document.createElement("div");
                preferredBarSizeDiv.className = "centered";
                preferredBarSizeDiv.style.position = "relative";
                preferredBarSizeDiv.style.width = (document.body.clientWidth).toString() + "px";
                preferredBarSizeDiv.appendChild(document.createElement("h1"))
                preferredBarSizeDiv.children[0].innerHTML = preferredBarSize;
                preferredBarSizeDiv.children[0].className = "preferredBarSize";
                resultContainer.appendChild(preferredBarSizeDiv);
                
                //Display speedrun time
                var resultsDiv = document.createElement("div");
                resultsDiv.className = "centered";
                resultsDiv.style.position = "relative";
                resultsDiv.style.width = (document.body.clientWidth).toString() + "px";
                resultContainer.appendChild(resultsDiv);
                
                totalSpaceUsed = 0;
                
                var resultHeadingClass = "resultHeading";
                var numCrawlers = resultsObj["data"].length;
                for(let index = 0; index < numCrawlers; index++)
                {
                    var crawlerResultDiv = document.createElement("div");
                    crawlerResultDiv.className = "crawlerResultDiv";
                    resultsDiv.appendChild(crawlerResultDiv);

                    var crawlerResultDescriptionDiv = document.createElement("div");
                    crawlerResultDescriptionDiv.className = "crawlerResultDiv";
                    crawlerResultDescriptionDiv.appendChild(document.createElement("p"));
                    crawlerResultDescriptionDiv.children[0].innerHTML = scoreObj["metric_name"] + ": " + "<br>";
                    if(scoreObj.hasOwnProperty("fixed_max_metric_value"))
                        crawlerResultDescriptionDiv.children[0].innerHTML += "Maximum " + scoreObj["metric_name"] + ": " + "<br>";
                    crawlerResultDescriptionDiv.children[0].innerHTML += "Points From Metric: ";
                    crawlerResultDescriptionDiv.children[0].className = "resultDescription";
                    crawlerResultDiv.appendChild(crawlerResultDescriptionDiv);
                    //crawlerResultDiv.style.width = Math.floor(crawlerResultDescriptionDiv.getBoundingClientRect()["width"]).toString() + "px";
                    
                    var crawlerResultValueDiv = document.createElement("div");
                    crawlerResultValueDiv.appendChild(document.createElement("p"));
                    crawlerResultValueDiv.className = "crawlerResultDiv";
                    
                    var currentScore = scoreObj["crawler_list"][index]["metric_score"];
                    var scoreColor = "";
                    if(currentScore > 0)
                        scoreColor = "green";
                    else if(currentScore < 0)
                        scoreColor =  "red";
                    
                    crawlerResultValueDiv.children[0].innerHTML = scoreObj["crawler_list"][index]["metric_value"] + "<br>";
                    if(scoreObj.hasOwnProperty("fixed_max_metric_value"))
                        crawlerResultValueDiv.children[0].innerHTML += scoreObj["fixed_max_metric_value"] + "s" + "<br>";
                        
                    crawlerResultValueDiv.children[0].innerHTML += '<span style="color:' + scoreColor + '">' + currentScore.toString() + "</span>";
                    crawlerResultValueDiv.children[0].className = "resultValue";
                    crawlerResultDiv.appendChild(crawlerResultValueDiv);
                    
                    totalSpaceUsed += crawlerResultDiv.getBoundingClientRect()["width"];
                }
                
                ///Adjust the spacing between the
                var spacingBetweenAxisValues = Math.floor((width - totalSpaceUsed) / (numCrawlers - 1));
                for(let index = 0; index < numCrawlers - 1; index++)
                {
                    resultsDiv.children[index].style.paddingRight = spacingBetweenAxisValues.toString() + "px";
                }
                
                //Display the bars for the crawlers
                totalSpaceUsed = 0;
                //Add crawlers' names
                var barClass = "bar";
                var maxBarWidth = width;
                var maxVal = parseInt(middleAxisValue) * 2;
                for(let index = 0; index < numCrawlers; index++)
                {
                    var currentBar = document.createElement("div");
                    var currentMetricValue = parseInt(scoreObj["crawler_list"][index]["metric_value"]);
                    var barWidth = Math.floor((currentMetricValue / maxVal) * maxBarWidth);
                    var crawlerName = scoreObj["crawler_list"][index]["crawler_name"];
                    currentBar.style.width = barWidth.toString() + "px";
                    currentBar.style.height = barDiv.style.height;
                    currentBar.className = barClass;
                    currentBar.style.backgroundColor = getKnownCrawlerColor(crawlerName);
                    
                    barDiv.appendChild(currentBar);
                    
                    totalSpaceUsed += currentBar.getBoundingClientRect()["width"];
                }
                resultLineDiv.insertBefore(barDiv, resultLineDiv.children[0]);
                
                ///Adjust the spacing between the
                var spacingBetweenAxisValues = Math.floor((width - totalSpaceUsed) / (numCrawlers - 1));
                for(let index = 0; index < numCrawlers - 1; index++)
                {
                    barDiv.children[index].style.marginRight = spacingBetweenAxisValues.toString() + "px";
                }
                
                if(!viewedScoresList.includes(scoringMetricIndex))
                {
                    updateScore(resultsObj, scoreObj, spaceBetweenTextAndValue=10, scoreAnimationDelay=scoreAnimationDelay);
                    viewedScoresList.push(scoringMetricIndex);
                }
            }
            
            function createDefaultScoreMultipliers(scoringMetrics)
            {
                scoreMultiplierList = [];
                for(let scoringMetricIndex = 0; scoringMetricIndex < scoringMetrics.length; scoringMetricIndex++)
                {
                    var performanceMetricIndex = scoringMetrics[scoringMetricIndex];
                    if(performanceMetricIndex == 2)
                    {
                        scoreMultiplierList.push(1);
                    }
                    else if(performanceMetricIndex == 4 || performanceMetricIndex == 7)
                    {
                        scoreMultiplierList.push(50);
                    }
                    else if(performanceMetricIndex == 3 || performanceMetricIndex == 8 || performanceMetricIndex == 9 || performanceMetricIndex == 11)
                    {
                        scoreMultiplierList.push(100);
                    }
                    else if(performanceMetricIndex == 5)
                    {
                        scoreMultiplierList.push(200);
                    }
                    else if(performanceMetricIndex == 6)
                    {
                        scoreMultiplierList.push(300);
                    }
                    else if(performanceMetricIndex == 10)
                    {
                        scoreMultiplierList.push(500);
                    }
                }
                
                return scoreMultiplierList;
            }
            
            
			createQRCode();
			var resultsObj = getResultsObj();
            var scoringMetrics = getScoringMetrics();
            var scoreMultiplierList = createDefaultScoreMultipliers(scoringMetrics);
			createButtons(resultsObj, scoringMetrics, scoreMultiplierList, [0]);//The [0] is associated with viewScoreList and it includes 0 because displayResult will be called immediately for the first metric
            displayTitleandCrawlerNames(resultsObj);
            //createTable(resultsObj);
            viewedScoresList = [];
            while(document.getElementById("total_scores") == null && document.getElementById("total_scores").children.length >= 2)
            {
                continue;
            }
            displayResult(resultsObj, scoringMetrics, 0, scoreMultiplierList, viewedScoresList, scoreAnimationDelay=4);
			
			
		</script>
		
		<!--
		<div id="qrcode-2"></div>
		<script type="text/javascript">
		var qrcode = new QRCode(document.getElementById("qrcode-2"), {
			text: "https://webisora.com",
			width: 128,
			height: 128,
			colorDark : "#5868bf",
			colorLight : "#ffffff",
			correctLevel : QRCode.CorrectLevel.H
		});
		-->
		</script>
	</body>
</html>
